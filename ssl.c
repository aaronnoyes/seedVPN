#include <openssl/ssl.h>
#include <string.h>
#include "ssl.h"

//password retrieved to decrypt keyfile
static char *keyfile_pass;

//callback to get password to decrypt keyfile
//should not be callable outside the library
static int get_keyfile_pass(char *buf, int num, int rwflag, void *userdata) {
    //get length of password
    int pass_len = strlen(keyfile_pass);
    if (num < pass_len +1) {
        return(0);
    }

    strcpy(buf, keyfile_pass);
    return(pass_len);
}

//dh params generated via openssl commandline
//openssl dhparam -C 2236
#ifndef HEADER_DH_H
#include <openssl/dh.h>
#endif
DH *get_dh2236()
        {
        static unsigned char dh2236_p[] = {
                0x09, 0xC2, 0x84, 0x3A, 0x7F, 0x4B, 0x1B, 0x37, 0x19, 0xAB, 0x71, 0x1D, 
                0x5B, 0x0A, 0x0E, 0xE4, 0x14, 0x5D, 0xF9, 0x3A, 0xE1, 0x7C, 0x4F, 0xC6, 
                0x5F, 0x3E, 0xB5, 0x31, 0x4F, 0x1E, 0x63, 0x9A, 0x40, 0x4B, 0x71, 0xD0, 
                0x06, 0x8D, 0x5A, 0x9C, 0xD8, 0xAD, 0xBA, 0x5E, 0x67, 0x47, 0x24, 0xFD, 
                0x10, 0x6B, 0x2A, 0x47, 0x1E, 0x92, 0xAA, 0x0F, 0xA7, 0x28, 0x83, 0x5D, 
                0x7E, 0xB3, 0x95, 0x06, 0xA2, 0xD0, 0x4B, 0xA9, 0x3E, 0x32, 0xFE, 0x45, 
                0xDF, 0xB2, 0x10, 0x33, 0x58, 0x0C, 0x16, 0x59, 0xE8, 0x02, 0x45, 0xA7, 
                0x4A, 0x85, 0x75, 0xDC, 0xE5, 0xBE, 0x51, 0x2A, 0xFF, 0x14, 0x3D, 0x8E, 
                0xCC, 0x90, 0x5C, 0x78, 0xB6, 0x6B, 0x7B, 0x3B, 0xBB, 0x03, 0xAC, 0x4B, 
                0xF8, 0xB2, 0x89, 0xF6, 0xF7, 0x32, 0xEE, 0x1E, 0x49, 0x17, 0x00, 0x43, 
                0xB4, 0x4C, 0x0F, 0xB7, 0x3B, 0xBF, 0x61, 0xCA, 0xB9, 0x78, 0x58, 0xD2, 
                0x4B, 0x6B, 0x45, 0x6E, 0x93, 0xA1, 0x5A, 0x5A, 0xB7, 0x93, 0x8B, 0xCD, 
                0xC3, 0xD6, 0x7D, 0x69, 0xAD, 0x87, 0xB6, 0x25, 0xC7, 0xA3, 0x69, 0x5C, 
                0x14, 0x11, 0x1A, 0x17, 0x86, 0x02, 0xB3, 0x58, 0xD3, 0x50, 0x31, 0xE3, 
                0x14, 0x87, 0xD9, 0x41, 0x6F, 0x57, 0xA3, 0x4E, 0x51, 0xB0, 0x16, 0x87, 
                0xD6, 0xF8, 0x9C, 0x55, 0xF5, 0x9A, 0xC4, 0x75, 0x11, 0xA0, 0xC5, 0x7E, 
                0x26, 0x8F, 0xA6, 0x10, 0x0B, 0xFB, 0x3A, 0xD0, 0xCC, 0xFB, 0x20, 0x2B, 
                0x3D, 0x26, 0x68, 0xE0, 0x63, 0x50, 0x79, 0xBE, 0x21, 0x22, 0x0C, 0x54, 
                0xA7, 0xAA, 0x10, 0xB3, 0x8B, 0x0E, 0xB9, 0xE6, 0xF5, 0x4B, 0x7A, 0xD6, 
                0x30, 0x35, 0xB7, 0xF4, 0x21, 0x73, 0x13, 0x8C, 0xF2, 0xC2, 0x7C, 0x20, 
                0xBB, 0x56, 0x47, 0x90, 0x5B, 0xEE, 0x79, 0x00, 0x39, 0x19, 0xF4, 0x20, 
                0x63, 0x55, 0x3B, 0x8A, 0xA3, 0xC9, 0x82, 0x99, 0xEA, 0xDE, 0xB3, 0xBD, 
                0x64, 0x24, 0xA9, 0x4A, 0xDB, 0x33, 0xF6, 0x40, 0xA3, 0xF3, 0x0F, 0xAE, 
                0x9F, 0xAF, 0x72, 0x0B, 
                };
        static unsigned char dh2236_g[] = {
                0x02, 
                };
        DH *dh;

        if ((dh = DH_new()) == NULL) return(NULL);
        dh->p = BN_bin2bn(dh2236_p, sizeof(dh2236_p), NULL);
        dh->g = BN_bin2bn(dh2236_g, sizeof(dh2236_g), NULL);
        if ((dh->p == NULL) || (dh->g == NULL))
                { DH_free(dh); return(NULL); }
        return(dh);
        }

SSL_CTX *ssl_init_ctx(char *cafile , char *keyfile, char *password, int server) {
    SSL_CTX *ctx;
    SSL_METHOD *method;

    //load library
    SSL_library_init();
    SSL_load_error_strings();

    //set up context using SSL/TLS
    //openSSL will negitiate the best to use
    method = TLS_method();
    if (!method) {
        perror("Failed to load SSL method");
        return NULL;
    }

    ctx = SSL_CTX_new(method);
    if (!ctx) {
        perror("Failed to get SSL ctx");
        return NULL;
    }

    //set ecdh params
    SSL_CTX_set_ecdh_auto(ctx, 1);

    //load the CA's cert
    if (!SSL_CTX_load_verify_locations(ctx, CA_FILE, NULL)) {
        perror("Failed to get load CA cert");
        return NULL;
    }

    //get the password to decrypt keyfile using get_keyfile_pass()
    keyfile_pass = password;
    SSL_CTX_set_default_passwd_cb(ctx, get_keyfile_pass);

    //load private key into context
    //private keys are in PEM format
    if(!(SSL_CTX_use_PrivateKey_file(ctx, keyfile, SSL_FILETYPE_PEM))) {
        perror("Failed to load private key file");
        return NULL;
    }

    return ctx;
}

SSL *ssl_do_handshake(int sock, SSL_CTX *ctx, int server) {
    BIO *bio;
    SSL *ssl;
    DH *dh;
    int conn_status;

    //need DH parameters for TLS
    dh = get_dh2236 ();
    if (1 != SSL_CTX_set_tmp_dh (ctx, dh)) {
        printf("Failed to set up DH parameters\n");
        return NULL;
    }

    //get ssl struct from context and bind BIO to the socket
    ssl = SSL_new(ctx);
    bio = BIO_new_socket(sock, BIO_NOCLOSE);

    //ssl should read and write via the BIO
    SSL_set_bio(ssl, bio, bio);

    //client and server should both check eachother's certificates
    SSL_set_verify(ssl, SSL_VERIFY_PEER, NULL);

    //server wait for connection
    //client try to connect
    if (server) {
        conn_status = SSL_accept(ssl);
    }
    else {
        conn_status = SSL_connect(ssl);
    }

    //if connection fails, return NULL
    if (conn_status != 1) {
        conn_status = SSL_get_error(ssl, conn_status);
        printf("Handshake failed with error #%d\n", conn_status);
        return NULL;
    }

    return ssl;
}

